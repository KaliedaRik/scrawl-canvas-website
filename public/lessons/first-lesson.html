<style>
  .code-block {
    border-color: #e2e8f0;
    background-color: #f7fafc;
    border-radius: 0.5rem;
    border-width: 1px;
    margin-bottom: 1rem;
    overflow-x: auto;
    padding: 1rem;
  }
  .code-block code {
    line-height: 1.25;
    color: #4a5568;
    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
    font-size: 0.875rem;
  }
  .code-block .redcode {
    color: #9b2c2c;
  }
  .code-block .heavycode {
    font-weight: 700;
    color: #9b2c2c;
  }
  .code-block .comment {
    color: #4a5568;
    font-size: 0.75rem;
  }
</style>

<p>The main purpose of Scrawl-canvas is to make building responsive canvas displays and animations easier. In this lesson we will briefly discuss the following:</p>

<ol class="list-decimal list-outside ml-4 mb-4">
	<li class="mb-2">Setup an html file for our code</li>
	<li class="mb-2">Include the scrawl-canvas code in a web page</li>
	<li class="mb-2">Build and display a Block entity on the canvas</li>
	<li class="mb-2">Style the Block entity when we create it</li>
	<li class="mb-2">Add some text to the canvas display using a Phrase entity</li>
</ol>

<p>This Codepen (which may take a while to run &mdash; our apologies for that) goes further than the above aims, but it does let you see how all the pieces fit together:</p>

<iframe height="600" style="width: 100%;" scrolling="no" title="Scrawl-canvas v8: Hello world" src="https://codepen.io/kaliedarik/embed/jObPbQX?height=600&theme-id=26779&default-tab=js,result&editable=true" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy">
  See the Pen <a href='https://codepen.io/kaliedarik/pen/jObPbQX'>Scrawl-canvas v8: Hello world</a> by Rik Roots
  (<a href='https://codepen.io/kaliedarik'>@kaliedarik</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<h2>Setup an html file for our code</h2>

<p>We start with a minimal HTML5 file. All the code we need will go into this file. Javascript and CSS code can be broken into separate files (as normal) as the page grows more complicated.</p>

<pre class="code-block"><code>&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
  &lt;meta charset='utf-8'>
  &lt;meta name='viewport' content='width=device-width,initial-scale=1'>

  &lt;title>Hello world&lt;/title>

  &lt;style type="text/css">
    <span class="redcode">canvas {
      background-color: yellow;
    }</span>
  &lt;/style>
&lt;/head>

&lt;body>
  &lt;canvas id="mycanvas">&lt;/canvas>

  <span class="heavycode">&lt;script type="module">
  &lt;/script></span>
&lt;/body>
&lt;/html>
</code></pre>

<h2>Include the scrawl-canvas code in a web page</h2>

<p>There's several ways to include Scrawl-canvas in a website or project:</p>

<ul class="list-disc list-outside ml-8 mb-4">
  <li class="mb-2">Use NPM or Yarn to add the library to a project &mdash; <code class="text-sm text-red-800">"npm install scrawl-canvas"</code>, or <code class="text-sm text-red-800">"yarn add scrawl-canvas"</code></li>
  <li class="mb-2">Download the files from GitHub (or from the link in the footer of this website) and add them to your project manually.</li>
  <li class="mb-2">Use a Content Distribution Network solution such as <a href="https://unpkg.com">unpkg.com</a> &mdash; this is the solution we shall use here.</li>
</ul>

<p>Scrawl-canvas is entirely modular: it has to be <b>imported</b> into your code inside a &lt;script> tag which has been marked as a module:</p>

<pre class="code-block"><code>[... canvas setup]

&lt;script type="module">
  <span class="redcode">import scrawl from 'https://unpkg.com/scrawl-canvas@8.6.3';</span>
&lt;/script>
</code></pre>

<p>Scrawl-canvas initializes itself the first time it is loaded into a web page. Subsequent imports return the scrawl object generated by that initial run. All the functionality we need is attached to the scrawl object.</p>

<p>As part of its initialization, Scrawl-canvas checks through the existing page structure and wraps any &lt;canvas> elements it finds in objects, ready for further work.</p>

<p>We defined one canvas element in our HTML and gave it an id of "mycanvas". We can use that id value to get a handle on the canvas wrapper object in our code:</p>

<pre class="code-block"><code>&lt;script type="module">
  import scrawl from 'https://unpkg.com/scrawl-canvas@8.6.3';

  <span class="redcode">let canvas = scrawl.library.canvas.mycanvas;</span>
&lt;/script>
</code></pre>

<p>Because there is only one Scrawl-canvas object per web page, while there may be many &lt;canvas> elements, it makes sense to <b>namespace</b> all the artefacts and other Scrawl-canvas objects that we are about to create &mdash; not only to prevent name clashes between canvas entitys, but also to make identifying and debugging this canvas's objects in the Scrawl-canvas library a bit easier.</p>

<p>Also, if there's more than one canvas present in the page, we need to make the canvas we are about to work on the <b>current canvas</b> &mdash; it's not essential, but it saves us having to worry about assigning our artefacts to the correct groups when we create them.</p>

<pre class="code-block"><code>&lt;script type="module">
  import scrawl from 'https://unpkg.com/scrawl-canvas@8.6.3';

  let canvas = scrawl.library.canvas.mycanvas;

  <span class="redcode">let namespace = 'hello-world';

  canvas.setAsCurrentCanvas();</span>
&lt;/script>
</code></pre>

<p>One final thing we can do, before we move on, is get rid of that horrid yellow background we gave the &lt;canvas> element in our CSS style declaration. Every Scrawl-canvas object can be updated using its <code class="text-sm text-red-800">.set({key:value, key:value})</code> function, which takes a single object argument.</p>

<p>Set functions always return the object, which means we can dot-chain an additional function call onto the set call:</p>

<pre class="code-block"><code>&lt;script type="module">
  import scrawl from 'https://unpkg.com/scrawl-canvas@8.6.3';

  let canvas = scrawl.library.canvas.mycanvas;

  let namespace = 'hello-world';

  <i class="comment">// We can chain our canvas wrapper invocations</i>
  <span class="redcode">canvas.set({

    backgroundColor: 'honeydew',
    
  }).setAsCurrentCanvas();</span>
&lt;/script>
</code></pre>

<p>To see our work so far, start a server (<a href="https://github.com/http-party/http-server">http-server</a> is a good enough choice) in the same folder as our html file (saved as <code class="text-sm text-red-800">index.html</code>) and point the browser to <a href="http://localhost:8080/">localhost:8080</a>. Our canvas is still very yellow - we'll fix that in a minute.</p>

<p><img class="mx-auto" src="/assets/lesson-01/01.png" /></p>

<h2>Build and display a Block entity on the canvas</h2>

<p>Before we go on, some definitions:</p>

<ul class="list-disc list-outside ml-8 mb-4">
  <li class="mb-2"><b>&lt;canvas> element</b> &mdash; this is the canvas element in the web page's HTML markup.</li>
  <li class="mb-2"><b>canvas wrapper</b> &mdash; the object that Scrawl-canvas creates to wrap the &lt;canvas> element. These objects are stored in the Scrawl-canvas library at <code class="text-sm text-red-800">scrawl.library.canvas[canvas-element-id-value]</code>.</li>
  <li class="mb-2">An <b>artefact</b> is any graphical or other object that Scrawl-canvas can position, manipulate and animate. The canvas wrapper is also an artefact, because we can position it in a Scrawl-canvas stack element.</li>
  <li class="mb-2">An <b>entity</b> is a graphical object which we create to display in a canvas element. All entitys (the mis-spelling is deliberate) are also artefacts. These objects are stored in the Scrawl-canvas library at <code class="text-sm text-red-800">scrawl.library.entity[entity-name-value]</code>.</li>
</ul>

<p>Scrawl-canvas supplies a number of <b>factory functions</b> for generating entitys such as Blocks, Wheels, Pictures, Phrases, Shapes, Looms, etc. The factory we shall use for generating our Block entity is <code class="text-sm text-red-800">scrawl.makeBlock()</code>.</p>

<p>The <b>Block entity</b> is the simplest of the entitys - a rectangle, with width and height dimensions:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  <span class="redcode">scrawl.makeBlock({

    name: `${namespace}-box`,

    width: 100,
    height: 100,
  });</span>
&lt;/script>
</code></pre>

<p>If we refresh our web page ... nothing changes. This is because we need to <b>render</b> our scene before we can see the changes.</p>

<p>To render the scene <b>once</b>, we can use the <code class="text-sm text-red-800">scrawl.render()</code> function:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    name: `${namespace}-box`,

    width: 100,
    height: 100,
  });

  <span class="heavycode">scrawl.render();</span>
&lt;/script>
</code></pre>

<p>After rendering, the canvas &mdash; which, by default, is 300px wide by 150px high &mdash; is no longer yellow, and we can see a black square (our Block entity) in the top-left corner.</p>

<p><img class="mx-auto" src="/assets/lesson-01/02.png" /></p>

<h3>Move the Block to the center of the canvas</h3>

<p>We can position our Block entity by setting two additional attributes when we create it: <code class="text-sm text-red-800">startX</code> and <code class="text-sm text-red-800">startY</code>. Like the width and height attributes, the start attributes can accept Numbers, which represent pixel values.</p>

<p>We can get the canvas's center coordinates by dividing its width and height by 2:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    name: `${namespace}-box`,

    width: 100,
    height: 100,

    <span class="redcode">startX: 150,
    startY: 75,</span>
  });

  [... canvas render]
&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/03.png" /></p>

<p>Now the Block has moved, but it's not in the right place. This is because <b>we draw all entitys from their top left corner</b>. Thus we need to take into account the Block's own dimensions and subtract half of that ...</p>

<p class="text-xl text-red-800"><i>... Actually, no. We <b>don't</b> have to do this!</i></p>

<p>Scrawl-canvas allows us to use String values to set entity start (and dimensions!) values, instead of Numbers. This is known as <b>relative positioning</b>. Let's change our Block to use String values:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    name: `${namespace}-box`,

    <i class="comment">// Update the dimension and coordinate values from absolute (px) Numbers to relative (%) Strings</i>
    <span class="redcode">width: '80%',
    height: '80%',

    startX: '10%',
    startY: '10%',</span>
  });

  [... canvas render]
&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/04.png" /></p>

<p>String percentage values represent an entity's position (and dimensions) values <b><i>relative to the canvas dimensions</i></b>. If the canvas dimensions change, then the entity's position (and dimensions) will automatically update to match their changed environment.</p>

<p>We can prove this by changing the canvas wrapper's dimensions:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  [... Block definition]

  <span class="redcode">canvas.set({
    width: 400,
    height: 400,
  });</span>

  [... canvas render]
&lt;/script>
</code></pre>

<p>If we save and run this code ... all we see is a bigger yellow canvas &mdash; with no Block. <b><i>We've gone backwards rather than forwards!</i></b></p>

<p><img class="mx-auto" src="/assets/lesson-01/05.png" /></p>

<h3>The Display cycle</h3>

<p>&lt;canvas> elements work by drawing a static bitmap graphic onto an area of a web page. To animate a canvas scene, we need to repeatedly update and redraw that bitmap quickly enough to fool the human brain into seeing the scene move.</p>

<p>The Display cycle works this way: first we <b>clear</b> the &lt;canvas> element. Then we <b>recalculate</b> our graphical objects and <b>paint</b> them - one by one - back onto the canvas. Ideally, we need to complete all this work in less than 16 milliseconds, as most browsers update their display 60 times a second.</p>

<p>Our code above fails because we are only performing these actions once, when we invoke <code class="text-sm text-red-800">scrawl.render()</code>. What we need is an animation loop function, which will call the render operation every time the browser checks whether it needs to perform a repaint.</p>

<p>So let's build one, using the <code class="text-sm text-red-800">scrawl.makeRender()</code> factory function:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  [... Block definition]

  canvas.set({
    width: 400,
    height: 400,
  });

  <i class="comment">// Replace our canvas render invocation with a Scrawl-canvas RenderAnimation object</i>
  <span class="heavycode">scrawl.makeRender({
    name: `${namespace}-animation`,
    target: canvas,
  });</span>
&lt;/script>
</code></pre>

<p>The <b>makeRender</b> factory generates a highly versatile Scrawl-canvas <code class="text-sm text-red-800">RenderAnimation</code> object which invokes the render function for us. It also allows us to target it onto one or more specified canvas wrappers - each canvas can have its own RenderAnimation object, if the web page design calls for it.</p>

<p>Furthermore, each RenderAnimation object comes with a set of Display cycle function hooks, giving us fine control over how the canvas scene animates, how users interact with it, etc. We'll investigate these hooks in a later lesson.</p>

<p><img class="mx-auto" src="/assets/lesson-01/06.png" /></p>

<p>We've fixed our immediate issue &mdash; we can see our Block entity again &mdash; but the fix has revealed a second issue. Our (light green) canvas appears to be swimming in a sea of yellow - as if we have resized the &lt;canvas> element, but not resized it at the same time. So what's going on?</p>

<h3>Scrawl-canvas Cells</h3>

<p>Painting the &lt;canvas> element can be an expensive operation; poorly executed, it can damage page performance, causing unsightly effects such as flickering and jagging.</p>

<p>To minimise painting requirements, Scrawl-canvas performs most canvas operations on a second, hidden canvas which it generates and wraps in a <b>Cell object</b>. Only as the last step in the Display cycle does this Cell get copied over to the &lt;canvas> element.</p>

<p>Every &lt;canvas> element will be supplied with its own <b>base Cell</b> by Scrawl-canvas during initialization. And we can add more Cells to a canvas if needed.</p>

<p>The reason we got the display above &mdash; our light green canvas Cell appearing inside the larger, yellow &lt;canvas> element &mdash; is because when we resized the canvas, we didn't propagate that resize down to its base Cell, which still has its original 300px by 150px dimensions.</p>

<p>The simplest way to fix this would be to apply the new dimensions directly to the base Cell using its <b>set</b> function (both <code class="text-sm text-red-800">canvas.base.set()</code> and <code class="text-sm text-red-800">canvas.setBase()</code> will work).</p>

<p>But this is not the only approach we can take. One alternative method is to setup our canvas so that it checks its own dimensions regularly and, when those dimensions change, update its base cell automatically with the new values. To do this, we set the canvas wrapper's <code class="text-sm text-red-800">checkForResize</code> flag to true:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  [... Block definition]

  canvas.set({
    width: 400,
    height: 400,

    <span class="redcode">checkForResize: true,
    fit: 'cover',</span>
  });

  scrawl.makeRender({
    name: `${namespace}-animation`,
    target: canvas,
  });
&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/07.png" /></p>

<p class="text-sm">Note: dynamic canvas resizing code was updated in version 8.6.0, which deprecated the old <code class="text-sm text-red-800">isComponent</code> flag in favour of the more descriptive <code class="text-sm text-red-800">checkForResize</code> flag. There are a number of different approaches to creating dynamic, responsive canvas elements - each with their own different outcomes. See the <a href="/demo/canvas-025.html" target="_blank">Canvas-025 demo</a> for a range of examples.</p>


<h3>Artefact handles</h3>

<p>The Block centering solution above works ... but it's not very elegant. We still need to do some calculations involving the Block's dimensions to decide what values to give to its start coordinates. A better solution would be to move the starting point from the Block's top-left corner to the middle of the Block.</p>

<p>We can do this very easily in Scrawl-canvas, by setting the entity's <b>handleX</b> and <b>handleY</b> values. These attributes work in the same way as the start attributes, except percentage String values are relative to the entity's own dimensions, not the cell dimensions:

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    name: `${namespace}-box`,

    width: '80%',
    height: '80%',

    startX: '50%',
    startY: '50%',

    <span class="redcode">handleX: '50%',
    handleY: '50%',</span>
  });

  [... canvas render]

&lt;/script>
</code></pre>

<h2>Style the Block entity when we create it</h2>

<p>As squares go, our Block is not very entertaining. We can make it more interesting by giving it a color, and adding a border to it.</p>

<ul class="list-disc list-outside ml-8 mb-4">
  <li class="mb-2">The <b>fillStyle</b> attribute takes a CSS color String, which then gets used to flood the entity.</li>
  <li class="mb-2">The <b>lineWidth</b> attribute is a Number representing the width of a border around the entity</li>
  <li class="mb-2">The <b>strokeStyle</b> attribute, like fillStyle, uses a CSS color to stroke the border</li>
</ul>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    name: `${namespace}-box`,

    width: '80%',
    height: '80%',

    <i class="comment">// In Scrawl-canvas, 'center' is the same as '50%'</i>
    <span class="redcode">startX: 'center',
    startY: 'center',</span>

    handleX: 'center',
    handleY: 'center',

    <span class="heavycode">fillStyle: 'linen',

    lineWidth: 25,
    strokeStyle: 'moccasin',</span>
  });

  [... canvas render]

&lt;/script>
</code></pre>

<p>The result ... is not quite what we expected it to be:</p>

<p><img class="mx-auto" src="/assets/lesson-01/08.png" /></p>

<p>The reason the Block is missing its moccasin border is because we have not told the entity to include it!</p>

<p>There are, in fact, a number of different ways in which we can <b>stamp</b> an entity onto the base Cell: fill only, stroke only, fill followed by stroke, etc.</p>

<p>The attribute that sets the stamp method is called <b>method</b>. It can accept the following String values: <code class="text-sm text-red-800">'fill', 'draw', 'fillAndDraw', 'drawAndFill', 'fillThenDraw', 'drawThenFill', 'clip', 'clear', 'none'</code>:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  scrawl.makeBlock({

    [... Block definition values]

    fillStyle: 'linen',

    lineWidth: 25,
    strokeStyle: 'moccasin',

    <span class="redcode">method: 'fillThenDraw',</span>
  });

  [... canvas render]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/09.png" /></p>

<p>We are not limited to colors for our fills and strokes: we can define and use gradients and radial gradients for both. We can also use images, via Pattern objects.</p>

<p>More, we can change the appearance of the stroke line &mdash; the way lines join together, the pointiness of angles and the shape of line ends. We can make the line solid, or dashed. Dashed lines can even be animated (the "marching ants" effect).</p>

<h2>Add some text to the canvas display using a Phrase entity</h2>

<p>&lt;canvas> elements support graphic text &mdash; though text rendered in a canvas will never look as sharp as text displayed in a normal DOM element.</p>

<p>Another reason to avoid graphical text is because it is entirely graphical: it cannot be 'seen' by assistive technology; it is not accessible to non-visual users.</p>

<p><i>The Scrawl-canvas <b>Phrase entity</b> solves the accessibility issue</i> by making sure its text gets added to both the &lt;canvas> element's display and the web page document. This allows us to use graphical text with a bit more confidence that we won't be breaking any accessibility rules or laws.</p>

<p>The factory function for creating a Phrase entity is <code class="text-sm text-red-800">scrawl.makePhrase()</code>:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  [... define Block]

  <span class="redcode">scrawl.makePhrase({

    name: `${namespace}-label`,
    text: 'Hello, world!',
  });</span>

  [... canvas render]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/10.png" /></p>

<p>The first thing to notice about our new Phrase (after you spot it, in the top left-hand corner) is that it has been rendered over two lines<sup>*</sup>. Phrase entitys automatically break their text into lines based on their <b>width</b> attribute, their <b>font</b> family and size, and the length of their <b>text</b> in that font.</p>

<p class="text-sm"><sup>*</sup>Note: this changed in version 8.2.0. When creating a Phrase attribute, it will automatically set its width to fit its text, thus it should fit onto a single line. To make the Phrase text appear on multiple lines, explicitly set its <code class="text-red-800">width</code> attribute to  the desired width.</p>

<p>Let's fix these issues now:</p>

<pre class="code-block"><code>&lt;script type="module">

  [... canvas setup]

  [... define Block]

  scrawl.makePhrase({

    name: `${namespace}-label`,
    text: 'Hello, world!',

    <i class="comment">// We can define width using Number or percentage String values</i>
    <span class="redcode">width: '100%',</span>

    <i class="comment">// The font value can be any valid CSS font String</i>
    <span class="redcode">font: '4.5em bold Garamond, sans-serif',</span>
  });

  [... canvas render]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/11.png" /></p>

<p>Let's try to position the Phrase in the middle of the canvas, just like we did with the Block entity. We'll also give it a bit of color:</p>

<pre class="code-block"><code>&lt;script type="module">

  [...]

  scrawl.makePhrase({

    name: `${namespace}-label`,
    text: 'Hello, world!',

    width: '100%',

    font: '4.5em bold Garamond, sans-serif',

    <span class="redcode">startX: 'center',
    startY: 'center',

    handleX: 'center',
    handleY: 'center',

    fillStyle: 'lightblue',

    lineWidth: 2,
    strokeStyle: 'blue',

    method: 'fillThenDraw',</span>
  });

  [...]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/12.png" /></p>

<p>The result seems a bit ... off &mdash; or is it?</p>

<p>In fact the Phrase is doing exactly what we asked it to do. The problem we have is that the width of the Phrase entity's text is smaller than the width of the entity itself. (If it was bigger, the text would have broken into two lines, with both words being on the left hand side of the canvas).</p>

<p>Scrawl-canvas Phrase entitys support <b>text justification</b> - we can justify the text within the Phrase's width either to the <code class="text-sm text-red-800">'left'</code> or the <code class="text-sm text-red-800">'right'</code>. We can also <code class="text-sm text-red-800">'center'</code> the text, or cause the individual words to spread themselves across the entire <code class="text-sm text-red-800">'full'</code> width.</p>

<pre class="code-block"><code>&lt;script type="module">

  [...]

  scrawl.makePhrase({

    name: `${namespace}-label`,
    text: 'Hello, world!',

    width: '100%',

    font: '4.5em bold Garamond, sans-serif',

    <span class="redcode">justify: 'full',</span>

    [...]
  });

  [...]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/13.png" /></p>

<p>Phrase entitys are versatile objects, allowing us to tweak the text's appearance in a number of different ways. For instance, the text above doesn't look <i>natural:</i> the gap between the two words looks too wide. We can change that by adding some space between the individual letters:</p>

<pre class="code-block"><code>&lt;script type="module">

  [...]

  scrawl.makePhrase({

    name: `${namespace}-label`,
    text: 'Hello, world!',

    width: '100%',

    font: '4.5em bold Garamond, sans-serif',

    justify: 'full',
    <span class="redcode">letterSpacing: 2,</span>

    [...]
  });

  [...]

&lt;/script>
</code></pre>

<p><img class="mx-auto" src="/assets/lesson-01/14.png" /></p>

<p class="text-sm italic">(<b>Note that</b> Phrase dimensions functionality changed in Scrawl-canvas v8.2.0 &mdash; text will display on a single line, with its width and height values automatically fitted to match the Phrase font's requirements. To force a Phrase entity to display over multiple lines you need to explicitly set a width value on it.)</p>

<h2>Try for yourself</h2>

<p>The CodePen at the top of the page is fully editable. Try changing some of the values to see what effect they have on the Phrase and Block entitys.</p>
