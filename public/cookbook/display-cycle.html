<style>
  .code-block {
    border-color: #e2e8f0;
    background-color: #f7fafc;
    border-radius: 0.5rem;
    border-width: 1px;
    margin-bottom: 1rem;
    overflow-x: auto;
    padding: 1rem;
  }
  .code-block code {
    line-height: 1.25;
    color: #4a5568;
    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
    font-size: 0.875rem;
  }
  .code-block .redcode {
    color: #9b2c2c;
  }
  .code-block .heavycode {
    font-weight: 700;
    color: #9b2c2c;
  }
  .code-block .comment {
    color: #4a5568;
    font-size: 0.75rem;
  }
</style>

<p>[Warning: article is still in draft]</p>

<h2>Issue</h2>

<p>We want to display our &lt;canvas> scene in the web page.</p>

<h2>Solution</h2>

<p>Invoke the <code class="text-sm text-red-800">Canvas</code> wrapper's <code class="text-sm text-red-800">.render()</code> function, or alternatively we can trigger each part of the <strong>Display cycle</strong> individually.</p>

<pre class="code-block"><code>&lt;canvas width="400" height="200" id="my-canvas-id">&lt;/canvas>

&lt;script type="module">
    import scrawl from "https://unpkg.com/scrawl-canvas@8.6.5";

    const canvas = scrawl.library.canvas['my-canvas-id'];

    scrawl.makeBlock({
        name: 'my-layer-block',
        group: canvas.base.name,
        dimensions: ['50%', '50%'],
        start: ['center', 'center'],
        handle: ['center', 'center'],
        fillStyle: 'red',
    });

    <i class="comment">// We can render the canvas in one invocation:</i>
    <span class="redcode">canvas.render();</span>

    <i class="comment">// &hellip; Or trigger each part of the Display cycle in turn:</i>
    <span class="redcode">canvas.clear();
    canvas.compile();
    canvas.show();</span>

    <i class="comment">// &hellip; Or render all the &lt;canvas> elements on the web page in one invocation:</i>
    <span class="redcode">scrawl.render();</span>

    <i class="comment">// &hellip; Or trigger each part of the Display cycle in turn, for all &lt;canvas> elements:</i>
    <span class="redcode">scrawl.clear();
    scrawl.compile();
    scrawl.show();</span>

    <i class="comment">// Alternatively, we can use a factory function to create an animation object
    // - this animates the scene, and makes it interactive:</i>
    <span class="redcode">scrawl.makeAnimation({
        name: 'my-animation',
        fn: function () {
            canvas.clear();
            canvas.compile();
            canvas.show();
        },
    });</span>

    <i class="comment">// &hellip; or we can build a renderAnimation convenience object to do the work for us:</i>
    <span class="redcode">scrawl.makeRender({
        name: 'my-animation',
        target: canvas,
    });</span>
&lt;/script></code></pre>

<h2>Discussion</h2>

<p>Rather than hide the complexities of rendering a canvas scene behind a simple invocation, Scrawl-canvas exposes a set of functions at both the page and the per-canvas level which allows us to create advanced, interactive scenes and animations.</p>

<p>We call the steps involved in rendering a scene a <code class="text-sm text-red-800">Display cycle</code>. Performing a Display cycle once will render a static scene; performing it many times, as part of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">Request Animation Frame</a> (RAF) loop, renders an interactive or animated scene.</p>

<p>We divide the Display cycle into three distinct actions:</p>

<ul class="list-disc list-outside ml-8 mb-4">
    <li class="mb-2">The <code class="text-sm text-red-800">.clear()</code> action clears the <code class="text-sm text-red-800">Canvas</code> wrapper's <code class="text-sm text-red-800">Cell</code>s in preparation for the work ahead</li>
    <li class="mb-2">For the <code class="text-sm text-red-800">.compile()</code> action, the <code class="text-sm text-red-800">Canvas</code> wrapper tells all the <code class="text-sm text-red-800">Cell</code>s associated with it to get their graphical entitys to stamp themselves into the <code class="text-sm text-red-800">Cell</code>'s drawing context.</li>
    <li class="mb-2">The <code class="text-sm text-red-800">.show()</code> action brings together all the work done by the <code class="text-sm text-red-800">Cell</code>s, which now stamp themselves into the <code class="text-sm text-red-800">Canvas</code> wrapper's base Cell, which in turn copies itself into the visible &lt;canvas> element.</li>
</ul>

<h4>Clear</h4>

<p>By default, a Scrawl-canvas <code class="text-sm text-red-800">Cell</code> will clear its rendering context using the Canvas API's <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect">.clearRect()</a> functionality. This call resets all the pixels in the <code class="text-sm text-red-800">Cell</code>'s hidden &lt;canvas> to transparent black (<code class="text-sm text-red-800">rgba(0,0,0,0)</code>).</p>

<p>Scrawl-canvas gives us three alternatives to this default action:</p> 

<ol class="list-decimal list-outside ml-8 mb-4">
    <li class="mb-2">Do not clear the canvas.</li>
    <li class="mb-2">Fill the canvas with a background color.</li>
    <li class="mb-2">Capture the existing scene, clear the canvas, then repost the scene capture at a given <code class="text-sm text-red-800">globalAlpha</code> level &mdash; this creates a "ghosting effect" in the scene for any animated entitys associated with that <code class="text-sm text-red-800">Cell</code>.</li>
</ol>

<h5>Suppress the clear action</h5>

<p>To stop a <code class="text-sm text-red-800">Cell</code> from clearing itself, set its <code class="text-sm text-red-800">.cleared</code> attribute to false.</p>

<p>A good reason for suppressing the clear action is to preserve a static part of the completed scene &mdash; particularly if the static graphic is complex or took a long time to generate.</p>

<h5>Use a background color</h5>

<p>To make a <code class="text-sm text-red-800">Cell</code> clear itself using a background color, set its <code class="text-sm text-red-800">.backgroundColor</code> attribute to <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">any valid CSS color string</a>.</p>

<p>We can also set this attribute on the <code class="text-sm text-red-800">Canvas</code> wrapper; in this case the wrapper will automatically cascade the color value down to its <code class="text-sm text-red-800">base Cell</code>.</p>

<h5>Create a ghosting effect</h5>

<p>The ghosting effect is a fairly niche requirement, where a series of previous frames are captured and restamped into the <code class="text-sm text-red-800">Cell</code> with the older frames being more transparent than the newer frames.</p>

<p>We can create the effect by setting the <code class="text-sm text-red-800">Cell</code>'s <code class="text-sm text-red-800">.clearAlpha</code> attribute to a value greater than 0.9 (to a maximum value of 1.0). Note that if the <code class="text-sm text-red-800">.backgroundColor</code> attribute has also been set, then the background effect takes precedence over the ghosting effect.</p>

<h4>Compile</h4>

<p>The compile action starts after the clear action completes. The action triggers a cascade of <code class="text-sm text-red-800">.stamp()</code> invocations on entitys associated with the <code class="text-sm text-red-800">Cell</code> via any <code class="text-sm text-red-800">Group</code>s associated with the <code class="text-sm text-red-800">Cell</code>.</p>

<h5>Compile order</h5>

<p>The order in which <code class="text-sm text-red-800">Cell</code>s compile can become important, especially when a <code class="text-sm text-red-800">Cell</code> is used as an asset for a <code class="text-sm text-red-800">Pattern</code> style or a <code class="text-sm text-red-800">Picture</code> entity in another <code class="text-sm text-red-800">Cell</code>. We change the compile order by setting a <code class="text-sm text-red-800">Cell</code>'s <code class="text-sm text-red-800">.compileOrder</code> attribute to an positive integer Number value.</p>

<p>If a Pattern or Picture whose graphical content is based on a <code class="text-sm text-red-800">Cell</code> asset does not appear in the output scene as expected, check that the <code class="text-sm text-red-800">Canvas</code> wrapper's base <code class="text-sm text-red-800">Cell</code>'s <code class="text-sm text-red-800">.compileOrder</code> value is greater than the asset's value.</p>

<h5>Suppressing the compile step</h5>

<p>We can prevent a <code class="text-sm text-red-800">Cell</code> from compiling itself as part of the Display cycle by setting its <code class="text-sm text-red-800">.compiled</code> attribute to <code class="text-sm text-red-800">false</code>.</p>

<p>One reason for disabling the compile step is to preserve the contents of a static <code class="text-sm text-red-800">Cell</code>, similar to the way we can suppress the clear action.</p>

<p>If we need to <code class="text-sm text-red-800">Cell</code> to compile just once, we can invoke the <code class="text-sm text-red-800">Cell</code>'s <code class="text-sm text-red-800">.compile()</code> function directly. Alternatively, if we are animating the scene with a RenderAnimation object, we can unset the <code class="text-sm text-red-800">.compiled</code> flag in an <code class="text-sm text-red-800">.afterCreated()</code> hook function which will run after the first Display cycle completes.</p>

<h4>Entity stamping during the compile action</h4>

<h4>Show</h4>

<h3>Example</h3>

<pre class="code-block"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>&lt;/head>
&lt;body>

    &lt;canvas id="my-canvas-id" width="600" height="600">&lt;/canvas>

    &lt;script type="module">
        
        <span class="redcode">import scrawl from "https://unpkg.com/scrawl-canvas@8.6.5";

        scrawl.setIgnorePixelRatio(false);

        const canvas = scrawl.library.canvas['my-canvas-id'];

        <i class="comment">// This layer Cell will be half the dimensions of its host Canvas </i>
        <i class="comment">// - we position it in the center of the canvas </i>
        <i class="comment">// - so it covers the lower-right quadrant of the display</i>
        const myLayer = canvas.buildCell({
            name: 'my-layer-cell',
            host: canvas.base.name,
            dimensions: ['50%', '50%'],
            start: ['center', 'center'],
        });

        <i class="comment">// This block stamps itself into the center of the layer Cell</i>
        const layerBlock = scrawl.makeBlock({
            name: 'my-layer-block',
            group: 'my-layer-cell',
            dimensions: ['50%', '50%'],
            start: ['center', 'center'],
            handle: ['center', 'center'],
            fillStyle: 'red',
        });

        <i class="comment">// This block stamps itself across the &lt;canvas> element's base Cell</i>
        <i class="comment">// - it will be twice the size of the previous block</i>
        const baseBlock = scrawl.makeBlock({
            name: 'my-base-block',
            group: canvas.base.name,
            dimensions: ['50%', '50%'],
            start: ['center', 'center'],
            handle: ['center', 'center'],
            fillStyle: 'blue',
        });

        <i class="comment">// Display the scene</i>
        canvas.render();

        <i class="comment">// Our layer Cell can act just like out Block entitys</i>
        <i class="comment">// - we can scale, flip, rotate and animate it</i>

        <i class="comment">// We can reposition all the entitys displayed in the layer Cell</i>
        <i class="comment">// - by repositioning the Cell itself</i>

        <i class="comment">// This update positions the layer Cell's Block exactly over the base Cell's Block</i>
        myLayer.set({
            handle: ['center', 'center'],
            scale: 1.9,
        });

        <i class="comment">// Update the scene</i>
        canvas.render();

        <i class="comment">// Let's get the our Block entitys to stamp themselves on each other's Cell</i>
        layerBlock.simpleStamp(canvas.base, {
            start: ['25%', '25%'],
            dimensions: ['50%', '50%'],
            fillStyle: 'green',
        });

        baseBlock.simpleStamp(myLayer, {
            start: ['75%', '75%'],
            dimensions: ['50%', '50%'],
        });

        canvas.show();</span>
    &lt;/script>

    &lt;/script>

&lt;/body>
&lt;/html></code></pre>

